Jessica Tomas - jpt0022

Novemeber 18, 2019

I implemented my cpu scheduler using a singly linked list of tasks. Tasks represented process and were added, removed, and created as needed. These mechanisms were implemented in a separate source code and header file to help with ease when implementing policies. I followed a similar structure in the different scheduling algorithms when creating them. First, I handled new arrivals each clock cycle and as they arrived moved them into the ready queue. Second, I handled running processes and checked to see if it was their time to end. If so, I moved them to the finished list and began the next process. This varied in fcfs and srtf only slightly. The arrivals worked exactly the same however the order of running the processes was the main difference. Shortest remaining time first required an extra step to check all the remaining times of the processes ready queue and selected the lowest one to run. Round robin also required an extra step to switch the running process every quantum time interval. When a process began to run I stored its waiting time and when a process ended I stored its finish time based on the current clock time. This allowed me to calculate the waiting times, turn around times, and response times for each process after running the scheduling algorithm. I iterated through the finish list summing all the different times up and placed them into the formulas and took the averages to calculate the different times. I implemented the command-line parser in my main function. My main function has two parameters. The first parameter is an integer that stores the number of arguments passed. This is internally calculated, and the user does not need to enter anything. The second argument is an array of char pointers listing all the arguments. The first argument written by the user is to be the file name while the second is to be what scheduling policy they wish to use. If they want to use RR then another parameter may be entered for the time quantum. My solution is fairly general but could be largely improved. Since the arrivals in the different policies are a very similar algorithm, a separate function handling arrivals would have been more efficient that writing it again in both policy functions. But overall the source code is general enough to easily add a new policy with ease. My program offers input error checking when a user inputs a file that cannot be opened. My code overall is fairly elegant but could be cleaned up to be more efficient. I was unable to completely implement RRâ€™s statistical information correctly since I has trouble handling switching between processes when one would finish before a quantum time increment. I began the project using an array to store the tasks however halfway through I realized since an array is static it is impossible to completely delete an element other than copying part of it entirely to a new array. Therefore, I decided to start over for the most part and implement a dynamic structure using a singly linked list. I noticed the dynamic structure was more easier to use for all policies and provided a better implementation. I also seperated the node functions into a different source code file which allowed me to adjust the node fuctions easily. 
